// Generated by `wit-bindgen-wrpc-go` 0.11.0. DO NOT EDIT!
package ticker

import (
	context "context"
	binary "encoding/binary"
	errors "errors"
	fmt "fmt"
	io "io"
	slog "log/slog"
	math "math"
	utf8 "unicode/utf8"
	wrpc "wrpc.io/go"
)

type TaskError struct {
	payload      any
	discriminant TaskErrorDiscriminant
}

func (v *TaskError) Discriminant() TaskErrorDiscriminant { return v.discriminant }

type TaskErrorDiscriminant uint8

const (
	TaskErrorNone  TaskErrorDiscriminant = 0
	TaskErrorError TaskErrorDiscriminant = 1
)

func (v *TaskError) String() string {
	switch v.discriminant {
	case TaskErrorNone:
		return "none"
	case TaskErrorError:
		return "error"
	default:
		panic("invalid variant")
	}
}
func (v *TaskError) GetNone() (ok bool) {
	if ok = (v.discriminant == TaskErrorNone); !ok {
		return
	}
	return
}
func (v *TaskError) SetNone() *TaskError {
	v.discriminant = TaskErrorNone
	v.payload = nil
	return v
}
func NewTaskErrorNone() *TaskError {
	return (&TaskError{}).SetNone()
}
func (v *TaskError) GetError() (payload string, ok bool) {
	if ok = (v.discriminant == TaskErrorError); !ok {
		return
	}
	payload, ok = v.payload.(string)
	return
}
func (v *TaskError) SetError(payload string) *TaskError {
	v.discriminant = TaskErrorError
	v.payload = payload
	return v
}
func NewTaskErrorError(payload string) *TaskError {
	return (&TaskError{}).SetError(
		payload)
}
func (v *TaskError) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	if err := func(v uint8, w io.Writer) error {
		b := make([]byte, 2)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u8 discriminant")
		_, err := w.Write(b[:i])
		return err
	}(uint8(v.discriminant), w); err != nil {
		return nil, fmt.Errorf("failed to write discriminant: %w", err)
	}
	switch v.discriminant {
	case TaskErrorNone:
	case TaskErrorError:
		payload, ok := v.payload.(string)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(1)
				if err != nil {
					return fmt.Errorf("failed to index nested variant writer: %w", err)
				}
				return write(w)
			}, nil
		}
	default:
		return nil, errors.New("invalid variant")
	}
	return nil, nil
}
func Task(ctx__ context.Context, wrpc__ wrpc.Invoker) (r0__ *TaskError, err__ error) {
	var w__ wrpc.IndexWriteCloser
	var r__ wrpc.IndexReadCloser
	w__, r__, err__ = wrpc__.Invoke(ctx__, "jamesstocktonj1:ticker/ticker@0.1.0", "task", nil)
	if err__ != nil {
		err__ = fmt.Errorf("failed to invoke `task`: %w", err__)
		return
	}
	defer func() {
		if err := r__.Close(); err != nil {
			slog.ErrorContext(ctx__, "failed to close reader", "instance", "jamesstocktonj1:ticker/ticker@0.1.0", "name", "task", "err", err)
		}
	}()
	if cErr__ := w__.Close(); cErr__ != nil {
		slog.DebugContext(ctx__, "failed to close outgoing stream", "instance", "jamesstocktonj1:ticker/ticker@0.1.0", "name", "task", "err", cErr__)
	}
	r0__, err__ = func(r wrpc.IndexReadCloser, path ...uint32) (*TaskError, error) {
		v := &TaskError{}
		n, err := func(r io.ByteReader) (uint8, error) {
			var x uint8
			var s uint
			for i := 0; i < 2; i++ {
				slog.Debug("reading u8 discriminant byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
				}
				if s == 7 && b > 0x01 {
					return x, errors.New("discriminant overflows an 8-bit integer")
				}
				if b < 0x80 {
					return x | uint8(b)<<s, nil
				}
				x |= uint8(b&0x7f) << s
				s += 7
			}
			return x, errors.New("discriminant overflows an 8-bit integer")
		}(r)
		if err != nil {
			return nil, fmt.Errorf("failed to read discriminant: %w", err)
		}
		switch TaskErrorDiscriminant(n) {
		case TaskErrorNone:
			return v.SetNone(), nil
		case TaskErrorError:
			payload, err := func(r interface {
				io.ByteReader
				io.Reader
			}) (string, error) {
				var x uint32
				var s uint8
				for i := 0; i < 5; i++ {
					slog.Debug("reading string length byte", "i", i)
					b, err := r.ReadByte()
					if err != nil {
						if i > 0 && err == io.EOF {
							err = io.ErrUnexpectedEOF
						}
						return "", fmt.Errorf("failed to read string length byte: %w", err)
					}
					if s == 28 && b > 0x0f {
						return "", errors.New("string length overflows a 32-bit integer")
					}
					if b < 0x80 {
						x = x | uint32(b)<<s
						if x == 0 {
							return "", nil
						}
						buf := make([]byte, x)
						slog.Debug("reading string bytes", "len", x)
						_, err = r.Read(buf)
						if err != nil {
							return "", fmt.Errorf("failed to read string bytes: %w", err)
						}
						if !utf8.Valid(buf) {
							return string(buf), errors.New("string is not valid UTF-8")
						}
						return string(buf), nil
					}
					x |= uint32(b&0x7f) << s
					s += 7
				}
				return "", errors.New("string length overflows a 32-bit integer")
			}(r)
			if err != nil {
				return nil, fmt.Errorf("failed to read `error` payload: %w", err)
			}
			return v.SetError(payload), nil
		default:
			return nil, fmt.Errorf("unknown discriminant value %d", n)
		}
	}(r__, []uint32{0}...)
	if err__ != nil {
		err__ = fmt.Errorf("failed to read result 0: %w", err__)
		return
	}
	return
}
